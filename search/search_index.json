{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ZonePlus is a module enabling the construction of dynamic zones. These zones utilise region checking, raycasting and the new BasePart.CanTouch property to effectively determine players and parts within their boundaries. Creating a zone is as simple as: -- Assuming we place ZonePlus in ReplicatedStorage local Zone = require ( game : GetService ( \"ReplicatedStorage\" ). Zone ) local zoneGroup = workspace . SafeZoneGroup local zone = Zone . new ( zoneGroup ) Zones take one argument: a group . A group can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts . Alternatively a group can be a singular basepart instance, or a table containing an array of baseparts. Info Zones are compatible with all basepart classes, however it's recommended to use simple parts (blocks, balls, cylinders, wedges, etc) where possible as these are more efficient and accurate. Some classes for instance, such as MeshParts and UnionOperations, require additional raycast checks to verify their surface geometries. These group parts are then used to define the region and precise bounds of the zone. Info Zones are dynamic. This means if a group part changes size or position, or if a basepart is added to or removed from the zone group, then an internal _update() method will be called to recalculate its bounds. Once constructed, you can utilise zone events to determine players, parts and the localplayer entering or exiting a zone. For instance, to listen for a player entering and exiting a zone, do: zone . playerEntered : Connect ( function ( player ) print (( \"%s entered the zone!\" ): format ( player . Name )) end ) zone . playerExited : Connect ( function ( player ) print (( \"%s exited the zone!\" ): format ( player . Name )) end ) Info On the client you may only wish to listen for the LocalPlayer (such as for an ambient system). To achieve this you would alternatively use the .localPlayer events. If you don't intend to frequently check for items entering and exiting a zone, you can utilise zone methods: local playersArray = zone : getPlayers () Discover the full set of methods, events and properties at the Zone module docs .","title":"Introduction"},{"location":"changelog/","text":"[2.0.0] - January 19 2021 \u00b6 Added \u00b6 Non-player part checking! (see methods below) Infinite zone volume, zero change in performance - zones can now be as large as you like with no additional impact to performance assuming characters/parts entering the zone remain their normal size or relatively small Zones now support MeshParts and UnionOperations (however it's recommended to use simple parts where possible as the former require additional raycast checks) Methods findLocalPlayer() findPlayer(player) findPart(basePart) getPlayers() getParts() setAccuracy(enumIdOrName) -- this enables you to customise the frequency of checks with enums 'Precise', 'High', 'Medium' and 'Low' 'Destroy' alias of 'destroy' Events localPlayerEntered localPlayerExited playerEntered playerExited partEntered partExited Changed \u00b6 A players whole body is now considered as apposed to just their central position Region checking significantly optimised (e.g. the zones region now rest on the voxel grid) Zones now act as a 'collective' which has significantly improved and optimised player and localplayer detection Removed all original aliases and events, including :initLoop() which no longer has to be called (connections are detected and handled internally automatically) Replaced frustrating require() dependencies with static modules Made Zone the parent module and others as descendants Removed the additonalHeight constructor argument - this caused confusion and added additional complexities to support :getRandomPoint() now returns randomVector, touchingGroupParts instead of randomCFrame, hitPart, hitIntersection Fixed \u00b6 Rotational and complex geometry detection getRandomPoints() inaccuracies","title":"Changelog"},{"location":"changelog/#200-january-19-2021","text":"","title":"[2.0.0] - January 19 2021"},{"location":"changelog/#added","text":"Non-player part checking! (see methods below) Infinite zone volume, zero change in performance - zones can now be as large as you like with no additional impact to performance assuming characters/parts entering the zone remain their normal size or relatively small Zones now support MeshParts and UnionOperations (however it's recommended to use simple parts where possible as the former require additional raycast checks) Methods findLocalPlayer() findPlayer(player) findPart(basePart) getPlayers() getParts() setAccuracy(enumIdOrName) -- this enables you to customise the frequency of checks with enums 'Precise', 'High', 'Medium' and 'Low' 'Destroy' alias of 'destroy' Events localPlayerEntered localPlayerExited playerEntered playerExited partEntered partExited","title":"Added"},{"location":"changelog/#changed","text":"A players whole body is now considered as apposed to just their central position Region checking significantly optimised (e.g. the zones region now rest on the voxel grid) Zones now act as a 'collective' which has significantly improved and optimised player and localplayer detection Removed all original aliases and events, including :initLoop() which no longer has to be called (connections are detected and handled internally automatically) Replaced frustrating require() dependencies with static modules Made Zone the parent module and others as descendants Removed the additonalHeight constructor argument - this caused confusion and added additional complexities to support :getRandomPoint() now returns randomVector, touchingGroupParts instead of randomCFrame, hitPart, hitIntersection","title":"Changed"},{"location":"changelog/#fixed","text":"Rotational and complex geometry detection getRandomPoints() inaccuracies","title":"Fixed"},{"location":"contributing/","text":"Suggestions and Code \u00b6 This project is completely free and open source therefore suggestions and code contributions are greatly appreciated! To make a suggestion, open an issue with label Type: Enhancement . Please open a suggestion issue before beginning a code contribution to ensure it's discussed through fully (we wouldn't want to waste your time!). Some tools you'll find useful when working on this project: Rojo Material for MKDocs Roblox LSP Documentation \u00b6 If you find any problems in the documentation, including typos, bad grammar, misleading phrasing, or missing content, feel free to file issues and pull requests to fix them. API documentation should be written at the top of the corresponding module under --[[ module:header . These comment blocks are automatically converted into markdown files and deployed to the site when pulled into the main branch. To test documentation: Install Material for MKDocs . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Change directory to this clone cd ZonePlus . Call mkdocs serve within your terminal. Open your local website (it will look something like http://0.0.0.0:8000/zone/ ) Any changes to mkdocs.yml or the files within docs will now update live to this local site. Info All pull requests must be made to the development branch. Bug Reports \u00b6 To submit a bug report open an issue with label Type: Bug . Ensure your report includes a detailed explanation of the problem with any relavent images (such as console errors). Submitting a resource (video tutorial, port, etc) \u00b6 Resources to improve the usability of this project are much welcome! Approved resources are featured in resources and potentially the discussion thread . To submit a resource, open an issue or reach out to ForeverHD on the devforum . Questions and Feedback \u00b6 Be sure to check out the documentation and resources first before asking a question. We recommend submitting all questions and feedback on the discussion thread . You can also open an issue with label Type: Question .","title":"Contributing"},{"location":"contributing/#suggestions-and-code","text":"This project is completely free and open source therefore suggestions and code contributions are greatly appreciated! To make a suggestion, open an issue with label Type: Enhancement . Please open a suggestion issue before beginning a code contribution to ensure it's discussed through fully (we wouldn't want to waste your time!). Some tools you'll find useful when working on this project: Rojo Material for MKDocs Roblox LSP","title":"Suggestions and Code"},{"location":"contributing/#documentation","text":"If you find any problems in the documentation, including typos, bad grammar, misleading phrasing, or missing content, feel free to file issues and pull requests to fix them. API documentation should be written at the top of the corresponding module under --[[ module:header . These comment blocks are automatically converted into markdown files and deployed to the site when pulled into the main branch. To test documentation: Install Material for MKDocs . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Change directory to this clone cd ZonePlus . Call mkdocs serve within your terminal. Open your local website (it will look something like http://0.0.0.0:8000/zone/ ) Any changes to mkdocs.yml or the files within docs will now update live to this local site. Info All pull requests must be made to the development branch.","title":"Documentation"},{"location":"contributing/#bug-reports","text":"To submit a bug report open an issue with label Type: Bug . Ensure your report includes a detailed explanation of the problem with any relavent images (such as console errors).","title":"Bug Reports"},{"location":"contributing/#submitting-a-resource-video-tutorial-port-etc","text":"Resources to improve the usability of this project are much welcome! Approved resources are featured in resources and potentially the discussion thread . To submit a resource, open an issue or reach out to ForeverHD on the devforum .","title":"Submitting a resource (video tutorial, port, etc)"},{"location":"contributing/#questions-and-feedback","text":"Be sure to check out the documentation and resources first before asking a question. We recommend submitting all questions and feedback on the discussion thread . You can also open an issue with label Type: Question .","title":"Questions and Feedback"},{"location":"examples/","text":"Safe Zone \u00b6 Paint Zone \u00b6 Coin Spawner \u00b6 Voting Pads \u00b6 Random Part Generator \u00b6 Ambient Areas \u00b6 All examples can be tested, viewed and edited at the Playground .","title":"Examples"},{"location":"examples/#safe-zone","text":"","title":"Safe Zone"},{"location":"examples/#paint-zone","text":"","title":"Paint Zone"},{"location":"examples/#coin-spawner","text":"","title":"Coin Spawner"},{"location":"examples/#voting-pads","text":"","title":"Voting Pads"},{"location":"examples/#random-part-generator","text":"","title":"Random Part Generator"},{"location":"examples/#ambient-areas","text":"All examples can be tested, viewed and edited at the Playground .","title":"Ambient Areas"},{"location":"installation/","text":"Method 1 - Take the model \u00b6 Take the ZonePlus model by Nanoblox. Open the toolbox and navigate to Inventory -> My Models. Click ZonePlus to insert into your game and place anywhere within ReplicatedStorage . Method 2 - Download from Releases \u00b6 Visit the latest release . Under Assets , download ZonePlus.rbxm . Within studio, navigate to MODEL -> Model and insert the file anywhere within ReplicatedStorage . Warning The release notes may not contain the most up-to-date version of ZonePlus. Use a different installation method if this is necessary. Method 3 - With Rojo \u00b6 Setup with Rojo . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Modify the default.project.json file to your desired location (by default ZonePlus is built directly into ReplicatedStorage ). Call rojo serve (terminal or VSC plugin) and connect to the rojo studio plugin.","title":"Installation"},{"location":"installation/#method-1-take-the-model","text":"Take the ZonePlus model by Nanoblox. Open the toolbox and navigate to Inventory -> My Models. Click ZonePlus to insert into your game and place anywhere within ReplicatedStorage .","title":"Method 1 - Take the model"},{"location":"installation/#method-2-download-from-releases","text":"Visit the latest release . Under Assets , download ZonePlus.rbxm . Within studio, navigate to MODEL -> Model and insert the file anywhere within ReplicatedStorage . Warning The release notes may not contain the most up-to-date version of ZonePlus. Use a different installation method if this is necessary.","title":"Method 2 - Download from Releases"},{"location":"installation/#method-3-with-rojo","text":"Setup with Rojo . Visit the ZonePlus repository . Click Fork in the top right corner. Clone this fork into your local repository. Modify the default.project.json file to your desired location (by default ZonePlus is built directly into ReplicatedStorage ). Call rojo serve (terminal or VSC plugin) and connect to the rojo studio plugin.","title":"Method 3 - With Rojo"},{"location":"method/","text":"Detection \u00b6 ZonePlus splits items into three categories: LocalPlayer Players Parts These categories then utilise unique methods to determine whether their corresponding item type is within a zone. Info It's important to understand that unlike in v1, zones now act as a collective through the ZoneController module. This means information can be generated once in a central area and shared with relavent zones, as apposed to each zone working independently. LocalPlayer \u00b6 While a localplayer-connection is active (i.e. when a developer connects to zone.localPlayerEntered/Exited )... Perform a RotatedRegion3 check within the local player. An array of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. Update each of these returned zones and determine whether .localPlayerEntered or .localPlayerExited should be fired. If active, calculate the clock time of the next check based upon the zone.accuracy enum. Players \u00b6 While a player-connection is active (i.e. when a developer connects to zone.playerEntered/Exited )... Compare the total volume of all zones against the total volume of all player characters (these are pre-determined through events instead of calculating every check). If the total characters volume is less than the total zone volume then: Iterate through each player in the server. Perform a RotatedRegion3 check within the local player. A collective of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. If a returned zone has an active player connection, update it and determine if .playerEntered(player) or .playerExited(player) should be called. Else if the total characters volume is greater than the total zone volume then: Iterate through each active zone. If the zone has an active player connection, perform a Region3 check of the zones rough area using all character parts within the server as a whitelist. Using a dictionary, match the bodyparts to their corresponding players. For each player detected, perform a precise RotatedRegion3 over their character to confirm they are exactly in the zone. Update the zone with these players and fire .playerEntered(player) and/or .playerExited(player) where necessary. If active, calculate the clock time of the next check based upon the zone.accuracy enum. Parts \u00b6 When a part-connection is formed (i.e. when a developer connects to zone.partEntered/Exited ), apply a touched event to all group-parts within the zone. When a part touches one of these group-parts, set its .CanTouch property to false . Fire .partEntered(part) and form a 'tracking connection' for the part. While this tracking connection is active... Perform a 'tiny region3 check' (of size (0.1, 0.1, 0.1) , using the zones group parts as a whitelist) to verify the parts center is still within the zone. If this returns false, then it means the part is either on the outer bounds of the zone or has exited. Now perform a whole-body RotatedRegion3 check, with the zones group parts as a whitelist. If this returns false, then the part has exited the zone. Fire .partExited(part) , disconnect the tracking connection and set the parts .CanTouch property back to true . Else if the tracking connection is still active, calculate the clock time of the next check based upon the zone.accuracy enum. If all part-connections are disconnected, disconnect all touched events and end any tracking connections. Optimisations \u00b6 A zones Region3 coordinates are rounded up to the nearest multiple of 4 to ensure it rests on the voxel grid. Region3 checks are favoured over raycasts for v2 for two reasons: A raycast must pass through a parts boundry from exterior to interior in order for it to be detected. This means tiny raycasts for example cannot be fired within a part to check for its surrounding zones as the zones group parts may completely engulf this part. Region checks enable the whole player/part to be considered as apposed to just the central position. When used in conjunction with whitelists can be as optimal as raycasting. There is however the caveat that if both zone and parts to check for (such as player characters) are both massive then this method becomes inferior (explained more next). The volume comparisons enable zones to determine players inside with optimal efficiency. For instance, if a server contains a single 8x8x8 zone and 100 players of size 4x5x1 , its significantly more efficient to check only the zone (of volume 512 ), as apposed to every player (of total volume 2000 ). Likewise, if you have multiple large zones which cover a map and few players in a server, it's going to be significantly more optimal to check each player as apposed to every zone. When a region check is performed on a MeshPart or UnionOperations, additional raycast checks must be performed (due to inaccurate bounding detection by Roblox for these part types) - two rays are fired, one above and the other below the zone, to determine its intesection Y vectors and whether the item falls inbetween these. It's therefore recommened to avoid using these special classes where possible. .Touched abuse checks are enforced to prevent parts firing these events more than the property value of whatever enum.accuracy is. In the future, we may consider modifying the 'Player' detection to something similar that of 'Parts'. The .CanTouch property is still very new therefore we'd like to fully explore its benefits/weaknesses first before considering so.","title":"Method"},{"location":"method/#detection","text":"ZonePlus splits items into three categories: LocalPlayer Players Parts These categories then utilise unique methods to determine whether their corresponding item type is within a zone. Info It's important to understand that unlike in v1, zones now act as a collective through the ZoneController module. This means information can be generated once in a central area and shared with relavent zones, as apposed to each zone working independently.","title":"Detection"},{"location":"method/#localplayer","text":"While a localplayer-connection is active (i.e. when a developer connects to zone.localPlayerEntered/Exited )... Perform a RotatedRegion3 check within the local player. An array of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. Update each of these returned zones and determine whether .localPlayerEntered or .localPlayerExited should be fired. If active, calculate the clock time of the next check based upon the zone.accuracy enum.","title":"LocalPlayer"},{"location":"method/#players","text":"While a player-connection is active (i.e. when a developer connects to zone.playerEntered/Exited )... Compare the total volume of all zones against the total volume of all player characters (these are pre-determined through events instead of calculating every check). If the total characters volume is less than the total zone volume then: Iterate through each player in the server. Perform a RotatedRegion3 check within the local player. A collective of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. If a returned zone has an active player connection, update it and determine if .playerEntered(player) or .playerExited(player) should be called. Else if the total characters volume is greater than the total zone volume then: Iterate through each active zone. If the zone has an active player connection, perform a Region3 check of the zones rough area using all character parts within the server as a whitelist. Using a dictionary, match the bodyparts to their corresponding players. For each player detected, perform a precise RotatedRegion3 over their character to confirm they are exactly in the zone. Update the zone with these players and fire .playerEntered(player) and/or .playerExited(player) where necessary. If active, calculate the clock time of the next check based upon the zone.accuracy enum.","title":"Players"},{"location":"method/#parts","text":"When a part-connection is formed (i.e. when a developer connects to zone.partEntered/Exited ), apply a touched event to all group-parts within the zone. When a part touches one of these group-parts, set its .CanTouch property to false . Fire .partEntered(part) and form a 'tracking connection' for the part. While this tracking connection is active... Perform a 'tiny region3 check' (of size (0.1, 0.1, 0.1) , using the zones group parts as a whitelist) to verify the parts center is still within the zone. If this returns false, then it means the part is either on the outer bounds of the zone or has exited. Now perform a whole-body RotatedRegion3 check, with the zones group parts as a whitelist. If this returns false, then the part has exited the zone. Fire .partExited(part) , disconnect the tracking connection and set the parts .CanTouch property back to true . Else if the tracking connection is still active, calculate the clock time of the next check based upon the zone.accuracy enum. If all part-connections are disconnected, disconnect all touched events and end any tracking connections.","title":"Parts"},{"location":"method/#optimisations","text":"A zones Region3 coordinates are rounded up to the nearest multiple of 4 to ensure it rests on the voxel grid. Region3 checks are favoured over raycasts for v2 for two reasons: A raycast must pass through a parts boundry from exterior to interior in order for it to be detected. This means tiny raycasts for example cannot be fired within a part to check for its surrounding zones as the zones group parts may completely engulf this part. Region checks enable the whole player/part to be considered as apposed to just the central position. When used in conjunction with whitelists can be as optimal as raycasting. There is however the caveat that if both zone and parts to check for (such as player characters) are both massive then this method becomes inferior (explained more next). The volume comparisons enable zones to determine players inside with optimal efficiency. For instance, if a server contains a single 8x8x8 zone and 100 players of size 4x5x1 , its significantly more efficient to check only the zone (of volume 512 ), as apposed to every player (of total volume 2000 ). Likewise, if you have multiple large zones which cover a map and few players in a server, it's going to be significantly more optimal to check each player as apposed to every zone. When a region check is performed on a MeshPart or UnionOperations, additional raycast checks must be performed (due to inaccurate bounding detection by Roblox for these part types) - two rays are fired, one above and the other below the zone, to determine its intesection Y vectors and whether the item falls inbetween these. It's therefore recommened to avoid using these special classes where possible. .Touched abuse checks are enforced to prevent parts firing these events more than the property value of whatever enum.accuracy is. In the future, we may consider modifying the 'Player' detection to something similar that of 'Parts'. The .CanTouch property is still very new therefore we'd like to fully explore its benefits/weaknesses first before considering so.","title":"Optimisations"},{"location":"resources/","text":"Model Playground Discussion Repository If you would like to submit a resource (such as a video tutorial, port, etc), please see contributing .","title":"Resources"},{"location":"third_parties/","text":"It's important only a single ZonePlus applications initiates at runtime otherwise its optimisations will diminish and other issues may occur. A developer may rename and/or place their Zone module anywhere within ReplicatedStorage therefore it's important for third party runtime applications (such as admin commands) to check and reference this correctly. To achieve this: When initiated, an ObjectValue called ZonePlusReference is added directly under ReplicatedStorage . Check for this. If present, require its value otherwise initiate your own ZonePlus. local runService = game : GetService ( \"RunService\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- This checks for the reference module under ReplicatedStorage local zonePlusReference = replicatedStorage : FindFirstChild ( \"ZonePlusReference\" ) local zoneModule = pathway . to . your . zoneplus if zonePlusReference then zoneModule = zonePlusReference . Value end -- Now use ZonePlus as normal local Zone = require ( zoneModule ) local zone = Zone . new ( zoneGroup )","title":"Third Parties"},{"location":"api/zone/","text":"Construtors \u00b6 new \u00b6 local zone = Zone . new ( group ) A group is used the define the boundaries of the zone. It can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts. Alternatively a group can be a singular basepart instance, or a table containing an array of baseparts. Methods \u00b6 findLocalPlayer \u00b6 local isWithinZoneBool = zone : findLocalPlayer () findPlayer \u00b6 local isWithinZoneBool = zone : findPlayer ( player ) findPart \u00b6 local isWithinZoneBool = zone : findPart ( basePart ) getPlayers \u00b6 local playersArray = zone : getPlayers () getParts \u00b6 local partsArray = zone : getParts () getRandomPoint \u00b6 local randomVector , touchingGroupPartsArray = zone : getRandomPoint () Generates random points within the zones region until one falls within its bounds. It then returns this Vector3 and a table array of group parts the point falls within. setAccuracy \u00b6 zone : setAccuracy ( enumIdOrName ) Sets the frequency of checks based upon the Accuracy Enum . destroy \u00b6 zone : destroy () Disconnects all connections within the zone. Events \u00b6 localPlayerEntered \u00b6 {client-only} zone . localPlayerEntered : Connect ( function () print ( \"you entered the zone!\" ) end ) localPlayerExited \u00b6 {client-only} zone . localPlayerExited : Connect ( function () print ( \"you exited the zone!\" ) end ) playerEntered \u00b6 zone . playerEntered : Connect ( function ( player ) print (( \"player '%s' entered the zone!\" ): format ( player . Name )) end ) playerExited \u00b6 zone . playerExited : Connect ( function ( player ) print (( \"player '%s' exited the zone!\" ): format ( player . Name )) end ) partEntered \u00b6 zone . partEntered : Connect ( function ( part ) print (( \"part '%s' entered the zone!\" ): format ( part . Name )) end ) Warning This connection will not fully optimise until BasePart.CanTouch goes live . partExited \u00b6 zone . partExited : Connect ( function ( part ) print (( \"part '%s' exited the zone!\" ): format ( part . Name )) end ) Warning This connection will not fully optimise until BasePart.CanTouch goes live . Properties \u00b6 accuracy \u00b6 local accuracyEnumId = zone . accuracy --[default: 'Enum.enums.Accuracy.High'] To change accuracy it's recommended you use setAccuracy . autoUpdate \u00b6 local bool = zone . autoUpdate --[default: 'true'] When true , the zone will update when its group parts change size or position, or when a descendant group part is added or removed from the group. respectUpdateQueue \u00b6 local bool = zone . respectUpdateQueue --[default: 'true'] When true , will prevent the internal _update() from being called multiple times within a 0.1 second period. region \u00b6 {read-only} volume \u00b6 {read-only}","title":"Zone"},{"location":"api/zone/#construtors","text":"","title":"Construtors"},{"location":"api/zone/#new","text":"local zone = Zone . new ( group ) A group is used the define the boundaries of the zone. It can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts. Alternatively a group can be a singular basepart instance, or a table containing an array of baseparts.","title":"new"},{"location":"api/zone/#methods","text":"","title":"Methods"},{"location":"api/zone/#findlocalplayer","text":"local isWithinZoneBool = zone : findLocalPlayer ()","title":"findLocalPlayer"},{"location":"api/zone/#findplayer","text":"local isWithinZoneBool = zone : findPlayer ( player )","title":"findPlayer"},{"location":"api/zone/#findpart","text":"local isWithinZoneBool = zone : findPart ( basePart )","title":"findPart"},{"location":"api/zone/#getplayers","text":"local playersArray = zone : getPlayers ()","title":"getPlayers"},{"location":"api/zone/#getparts","text":"local partsArray = zone : getParts ()","title":"getParts"},{"location":"api/zone/#getrandompoint","text":"local randomVector , touchingGroupPartsArray = zone : getRandomPoint () Generates random points within the zones region until one falls within its bounds. It then returns this Vector3 and a table array of group parts the point falls within.","title":"getRandomPoint"},{"location":"api/zone/#setaccuracy","text":"zone : setAccuracy ( enumIdOrName ) Sets the frequency of checks based upon the Accuracy Enum .","title":"setAccuracy"},{"location":"api/zone/#destroy","text":"zone : destroy () Disconnects all connections within the zone.","title":"destroy"},{"location":"api/zone/#events","text":"","title":"Events"},{"location":"api/zone/#localplayerentered","text":"{client-only} zone . localPlayerEntered : Connect ( function () print ( \"you entered the zone!\" ) end )","title":"localPlayerEntered"},{"location":"api/zone/#localplayerexited","text":"{client-only} zone . localPlayerExited : Connect ( function () print ( \"you exited the zone!\" ) end )","title":"localPlayerExited"},{"location":"api/zone/#playerentered","text":"zone . playerEntered : Connect ( function ( player ) print (( \"player '%s' entered the zone!\" ): format ( player . Name )) end )","title":"playerEntered"},{"location":"api/zone/#playerexited","text":"zone . playerExited : Connect ( function ( player ) print (( \"player '%s' exited the zone!\" ): format ( player . Name )) end )","title":"playerExited"},{"location":"api/zone/#partentered","text":"zone . partEntered : Connect ( function ( part ) print (( \"part '%s' entered the zone!\" ): format ( part . Name )) end ) Warning This connection will not fully optimise until BasePart.CanTouch goes live .","title":"partEntered"},{"location":"api/zone/#partexited","text":"zone . partExited : Connect ( function ( part ) print (( \"part '%s' exited the zone!\" ): format ( part . Name )) end ) Warning This connection will not fully optimise until BasePart.CanTouch goes live .","title":"partExited"},{"location":"api/zone/#properties","text":"","title":"Properties"},{"location":"api/zone/#accuracy","text":"local accuracyEnumId = zone . accuracy --[default: 'Enum.enums.Accuracy.High'] To change accuracy it's recommended you use setAccuracy .","title":"accuracy"},{"location":"api/zone/#autoupdate","text":"local bool = zone . autoUpdate --[default: 'true'] When true , the zone will update when its group parts change size or position, or when a descendant group part is added or removed from the group.","title":"autoUpdate"},{"location":"api/zone/#respectupdatequeue","text":"local bool = zone . respectUpdateQueue --[default: 'true'] When true , will prevent the internal _update() from being called multiple times within a 0.1 second period.","title":"respectUpdateQueue"},{"location":"api/zone/#region","text":"{read-only}","title":"region"},{"location":"api/zone/#volume","text":"{read-only}","title":"volume"},{"location":"api/zone_controller/","text":"Functions \u00b6 getZones \u00b6 local zonesArray = ZoneController . getZones () getCharacterRegion \u00b6 local charRegion , regionCFrame , charSize = ZoneController . getCharacterRegion ( player ) getTouchingZones \u00b6 local touchingZonesArray = ZoneController . getTouchingZones ( player ) getHeightOfParts \u00b6 local height , minY , maxY = ZoneController . getHeightOfParts ( tableOfParts ) vectorIsBetweenYBounds \u00b6 local bool = ZoneController . vectorIsBetweenYBounds ( vector , tableOfParts ) verifyTouchingParts \u00b6 local bool = ZoneController . verifyTouchingParts ( vectors , tableOfParts )","title":"ZoneController"},{"location":"api/zone_controller/#functions","text":"","title":"Functions"},{"location":"api/zone_controller/#getzones","text":"local zonesArray = ZoneController . getZones ()","title":"getZones"},{"location":"api/zone_controller/#getcharacterregion","text":"local charRegion , regionCFrame , charSize = ZoneController . getCharacterRegion ( player )","title":"getCharacterRegion"},{"location":"api/zone_controller/#gettouchingzones","text":"local touchingZonesArray = ZoneController . getTouchingZones ( player )","title":"getTouchingZones"},{"location":"api/zone_controller/#getheightofparts","text":"local height , minY , maxY = ZoneController . getHeightOfParts ( tableOfParts )","title":"getHeightOfParts"},{"location":"api/zone_controller/#vectorisbetweenybounds","text":"local bool = ZoneController . vectorIsBetweenYBounds ( vector , tableOfParts )","title":"vectorIsBetweenYBounds"},{"location":"api/zone_controller/#verifytouchingparts","text":"local bool = ZoneController . verifyTouchingParts ( vectors , tableOfParts )","title":"verifyTouchingParts"}]}